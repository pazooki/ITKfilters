#include "gtest/gtest.h"
#include <memory>
#include <string>
#include <cmath>
#include "prog_options_test.h"
#include "itkImage.h"
#include "itkImageFileReader.h"
#include "itkWaveletFrequencyFilterBankGenerator.h"
#include "itkHeldWavelet.h"
#include "itkVowWavelet.h"
#include "itkForwardFFTImageFilter.h"
#include "itkInverseFFTImageFilter.h"
#include <itkComplexToRealImageFilter.h>
#include "visualize_functions.h"
#include <itkImageRegionConstIterator.h>
using namespace std;
using namespace itk;

int main(int argc, char** argv){
    auto option_map = program_options(argc, argv);
    bool VFLAG = option_map["visualize"].as<bool>();
    bool DEBUG = option_map["debug"].as<bool>();
    unsigned int input_n = option_map["input_n"].as<int>();
    // const string img_file{"/home/phc/repository_local/ITKfilters/src/fixtures/collagen_98x98x20.tiff"};
    const string img_file{"/home/phc/repository_local/ITKfilters/src/fixtures/collagen_64x64x16.tiff"};
    const unsigned int dimension = 3;
    using PixelType = double;
    using ImageType = itk::Image<PixelType, dimension>;
    using ReaderType = itk::ImageFileReader<ImageType>;
    auto reader = ReaderType::New();
    reader->SetFileName(img_file);
    reader->Update();
    reader->UpdateLargestPossibleRegion();

    // Perform FFT on input image.
    typedef itk::ForwardFFTImageFilter<ImageType> FFTFilterType;
    typename FFTFilterType::Pointer fftFilter = FFTFilterType::New();
    fftFilter->SetInput(reader->GetOutput());
    fftFilter->Update();
    typedef typename FFTFilterType::OutputImageType ComplexImageType;

    // Set the WaveletFunctionType and the WaveletFilterBank
    // typedef itk::HeldWavelet<> WaveletFunctionType;
    typedef itk::VowWavelet<> WaveletFunctionType;
    typedef itk::WaveletFrequencyFilterBankGenerator< ComplexImageType, WaveletFunctionType> WaveletFilterBankType;
    typename WaveletFilterBankType::Pointer forwardFilterBank = WaveletFilterBankType::New();
    unsigned int high_sub_bands = input_n;
    forwardFilterBank->SetHighPassSubBands(high_sub_bands);
    forwardFilterBank->SetSize(fftFilter->GetOutput()->GetLargestPossibleRegion().GetSize());
    forwardFilterBank->SetDebug(DEBUG);
    forwardFilterBank->Update();
    // forwardFilterBank->Print(std::cout);

    //Get real part of complex image for visualization
    typedef itk::ComplexToRealImageFilter<ComplexImageType, ImageType> ComplexToRealFilter;
    typename ComplexToRealFilter::Pointer complexToRealFilter = ComplexToRealFilter::New();
    std::cout << "Real Part of ComplexImage:"<< std::endl;
    for (unsigned int i = 0 ; i < high_sub_bands + 1 ; ++i)
    {
        std::cout << "Band: " << i << " / " << forwardFilterBank->GetHighPassSubBands() << std::endl;
        // std::cout << "Largest Region: " << forwardFilterBank->GetOutput(i)->GetLargestPossibleRegion() << std::endl;

        complexToRealFilter->SetInput(forwardFilterBank->GetOutput(i) );
        complexToRealFilter->Update();
        if(VFLAG) visualize::VisualizeITKImage(complexToRealFilter->GetOutput());
    }

    // Inverse FFT Transform
    typedef itk::InverseFFTImageFilter<ComplexImageType, ImageType> InverseFFTFilterType;
    typename InverseFFTFilterType::Pointer inverseFFT = InverseFFTFilterType::New();
    if(VFLAG) std::cout << "InverseFFT:"  << std::endl;
    for (unsigned int i = 0 ; i < high_sub_bands + 1 ; ++i)
    {
        if(VFLAG) std::cout << "Band: " << i << " / " << forwardFilterBank->GetHighPassSubBands() << std::endl;
        inverseFFT->SetInput(forwardFilterBank->GetOutput(i) );
        inverseFFT->Update();
        if(VFLAG) visualize::VisualizeITKImage(inverseFFT->GetOutput());
    }
    // Create a new filter for the inverse Filter Bank
    // TODO if you just change the InverseFlag, the output already generated by the filter will get overriden, and trigger the pipeline.
    typename WaveletFilterBankType::Pointer inverseFilterBank = WaveletFilterBankType::New();
    inverseFilterBank->SetInverseBank(true);
    inverseFilterBank->SetHighPassSubBands(high_sub_bands);
    inverseFilterBank->SetSize(fftFilter->GetOutput()->GetLargestPossibleRegion().GetSize());
    inverseFilterBank->SetDebug(DEBUG);
    inverseFilterBank->Update();
    // inverseFilterBank->Print(std::cout);

    //Compare images: TODO use itk test facilities instead of region iterators?
    // itk::Testing::ComparisonImageFilter does not work with complex
    typedef typename itk::ImageRegionConstIterator<ComplexImageType>     ComplexConstRegionIterator;
    unsigned int ne = 0;
    for (unsigned int i = 0 ; i < high_sub_bands + 1 ; ++i)
      {
      typename ComplexImageType::Pointer outForward = forwardFilterBank->GetOutput(i);
      typename ComplexImageType::Pointer outInverse = inverseFilterBank->GetOutput(i);
      ComplexConstRegionIterator itForward(outForward, outForward->GetLargestPossibleRegion() );
      ComplexConstRegionIterator itInverse(outInverse, outInverse->GetLargestPossibleRegion() );
      itForward.GoToBegin();
      itInverse.GoToBegin();
      unsigned int ne_per_band = 0;
      while(!itForward.IsAtEnd() || !itInverse.IsAtEnd())
        {
        if(itForward.Get() != itInverse.Get())
            ++ne_per_band;
        ++itForward;
        ++itInverse;
        }
      ne+= ne_per_band;
      }
    if (ne > 0 )
        std::cout << "Comparison Error, num of errors: " << ne << '\n';
    else
        std::cout << "Pass! no comparison errors: " << ne << '\n';
}
